#!/usr/bin/python# eMPL_client.py# A PC application for use with Embedded MotionApps.# Copyright 2012 InvenSense, Inc. All Rights Reserved.import serial, sys, time, string, pygame, structfrom ponycube import *class eMPL_packet_reader:    def __init__(self, port_clip, port_head, quat_delegate):        self.s = serial.Serial(port_clip,115200)        self.s_head = serial.Serial(port_head,115200)        self.quat_delegate = quat_delegate        self.packets = []        self.length = 0        self.previous = None    def read(self):        NUM_BYTES = 24        p = None        while self.s.inWaiting() >= NUM_BYTES or self.s_head.inWaiting() >= NUM_BYTES:            if self.s.inWaiting() >= NUM_BYTES:                rs = self.s.read(NUM_BYTES)                if ord(rs[0]) == ord('$'):                    pkt_code = ord(rs[1])                    if pkt_code == 2:                        p = quat_packet(rs)                        self.quat_delegate.dispatch(p)                 else:                    c = ' '                    print "serial misaligned!"                    while not ord(c) == ord('$'):                        c = self.s.read(1)                    self.s.read(NUM_BYTES-1)            if self.s_head.inWaiting() >= NUM_BYTES:                rs = self.s_head.read(NUM_BYTES)                if ord(rs[0]) == ord('$'):                    pkt_code = ord(rs[1])                    if pkt_code == 2:                        p = quat_packet(rs)                        self.quat_delegate.dispatch(p, False)                 else:                    c = ' '                    print "serial misaligned!"                    while not ord(c) == ord('$'):                        c = self.s_head.read(1)                    self.s_head.read(NUM_BYTES-1)    def write(self,a):        self.s.write(a)    def close(self):        self.s.close()        self.s_head.close()    def write_log(self,fname):        f = open(fname,'w')        for p in self.packets:            f.write(p.logfile_line())        f.close()# ===========  PACKET DELEGATES  ==========class cube_packet_viewer (object):    def __init__(self):        self.screen = Screen(480,400,scale=1.5)        self.cube = Cube(30,60,10)        self.q = Quaternion(1,0,0,0)        self.previous = None  # previous quaternion        self.latest = None    # latest packet (get in dispatch, use in loop)        self.latest_head = None    def loop(self,event):        packet = self.latest        packet_head = self.latest_head        if packet and packet_head:            q = packet.to_q().normalized()            q_head = packet_head.to_q().normalized()            q_clip_to_head = q_head * q.conjugated()            self.cube.erase(self.screen)            self.cube.b = (255 - packet.b)/4 + 10            self.cube.draw(self.screen,q_clip_to_head.normalized())            pygame.display.flip()            self.latest = None            self.latest_head = None    def dispatch(self, p, isclip = True):        if isinstance(p,quat_packet):            if isclip:                self.latest = p            else:                self.latest_head = p# =============== PACKETS ================= def float_32(d1, d2, d3, d4):    d = ''.join(chr(x) for x in [ord(d4),ord(d3),ord(d2),ord(d1)])    return struct.unpack('f',d)[0]class quat_packet (object):    def __init__(self, l):        self.l = l        self.q0 = float_32(l[3],l[4],l[5],l[6])        self.q1 = float_32(l[7],l[8],l[9],l[10])        self.q2 = float_32(l[11],l[12],l[13],l[14])        self.q3 = float_32(l[15],l[16],l[17],l[18])        self.b = ord(l[21])        #self.display()    def display_raw(self):        l = self.l        print "".join(            [ str(ord(l[0])), " "] + \            [ str(ord(l[1])), " "] + \            [ str(ord(a)).ljust(4) for a in                                 [ l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9], l[10] ] ] + \            [ str(ord(a)).ljust(4) for a in                                 [ l[8], l[9], l[10] , l[11], l[12], l[13]] ]            )    def display(self):        if 1:            sys.stdout.write( "qs " + " ".join([str(s).ljust(15) for s in                [ self.q0, self.q1, self.q2, self.q3 ]]) + "\n")        if 0:            euler0, euler1, euler2 = self.to_q().get_euler()            print "eulers " + " ".join([str(s).ljust(15) for s in                [ euler0, euler1, euler2 ]])        if 0:            euler0, euler1, euler2 = self.to_q().get_euler()            print "eulers " + " ".join([str(s).ljust(15) for s in                [ (euler0 * 180.0 / 3.14159) - 90 ]])    def to_q(self):        return Quaternion(k0*self.q0, k1*self.q2, k2*self.q3, k3*self.q1)# =============== MAIN ======================k0 = 1k1 = 1k2 = 1k3 = 1if __name__ == "__main__":    #if len(sys.argv) == 2:    comport_clip = 'COM11' #int(sys.argv[1]) - 1    comport_head = 'COM6'    #else:    #    print "usage: " + sys.argv[0] + " port"    #    sys.exit(-1)    pygame.init()    viewer = cube_packet_viewer()    reader = eMPL_packet_reader(comport_clip, comport_head, quat_delegate = viewer)    while 1:        event = pygame.event.poll()        # TODO: Allow exit via keystroke.        if event.type == pygame.QUIT:            viewer.close()            break        if event.type == pygame.KEYDOWN:            if event.key == 49:#1                k0 = -k0            elif event.key == 50:#2                k1 = -k1            elif event.key == 51:#3                k2 = -k2            elif event.key == 52:#4                k3 = -k3            #sys.stdout.write(str(event.key))            sys.stdout.write("".join([str(k0),str(k1),str(k2),str(k3),'\n']))            #reader.write(pygame.key.name(event.key))        reader.read()        viewer.loop(event)        # TODO: If system load is too high, increase this sleep time.        pygame.time.delay(0)